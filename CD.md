# GitLab для Continuous Delivery проекта на технологиях InterSystems 

В данной статье хотелось бы рассказать про организацию процессов [Continuous Integration](https://ru.wikipedia.org/wiki/Непрерывная_интеграция) / Continuous Delivery, автоматизирующих сборку, тестирование и доставку приложений применимо к решениям на платформе InterSystems. 
Рассмотри такие темы как:

- Git 101
- Методологии разработки на основе Git
  - GitHub flow
  - GitLab flow
- GitLab
- GitLab CI

## Git 101

Несмотря на то, что основная тема это CD, [Git](https://ru.wikipedia.org/wiki/Git#Преимущества_и_недостатки), а точнее ряд фундаментальных принципов лежащих в его основе оказали влияние на процессы разработки программного обеспечения.
Git — система контроля и управления версиями, в основе:

- Нелинейная разработка - несмотря на то, что версии приложения выходят последовательно: 1, 2, 3 - разработка каждой версии ведётся праллельно несколькими разработчиками, которые могут одновременно править одни и те же части приложения.
- Распределённая разработка - разработчик независим от центрального сервера и может разрабатывать в своём локальном окружении без каких либо проблем.
- Слияние - реализация предыдущих двух пунктов приводит к тому, что существует несколько корректных версий пректа одновременно и часто нужно их объединять в единую версию правды.

Git не был первой системой контроля версий в которой данные идеи были реализованы, однако Git популяризовал данные идеи и существенно упростил их применение.

### Репозитоий (Repository)

Место, где хранятся и поддерживаются какие-либо данные.

- “Физически” — папка в ОС
- Хранит файлы и папки
- Хранит историю их изменения

Локальный репозиторий — репозиторий, расположенный на локальном компьютере 
Удалённый репозиторий — репозиторий, находящийся на удалённом сервере

### Коммит (Commit)

Зафиксированное состояние репозитория.
Diff (отличие) от какого-либо другого коммита который называется родительским.

Родителей бывает:
- 0 – у первого коммита
- 1 – как правило бывает именно так
- 2 – для слияния изменений
- 3+ - для слияния изменений (но так делать не надо)

### Ветка (Branch)

Указатель на коммит.
Всегда можно посмотреть на его историю до первого коммита. Например, ветка `master`:

![Ветка](https://community.intersystems.com/sites/default/files/inline/images/risunok1_0.png)


#### Дерево коммитов

Коммиты образуют деревья - графическое представление репозитория. Рассмотрим самый простой линейный вариант, когда к двум существующим коммитам с картинки выше добавили ещё три коммита:

![ветка](https://community.intersystems.com/sites/default/files/inline/images/risunok2.png)

Теперь пример дерева посложнее: два разработчика работают одновременно и, чтобы не мешать друг другу каждый из них работает в своей ветке. Это выглядит так:

![ветка](https://community.intersystems.com/sites/default/files/inline/images/risunok3.png)

Через некоторое время им надо обьединить изменения, для этого существуют *запросы на слияние* - запросы на объединение дваух состояний репозитория в одно новое состояние. В нашем случае запрос на слияние ветки `develop` в ветку `master`. После того как запрос был рассмотрен и одобрен и слияние произошло репозиторий выглядит следующим образом:

![ветка](https://community.intersystems.com/sites/default/files/inline/images/risunok4.png)

После чего разработка продолжается:

![ветка](https://community.intersystems.com/sites/default/files/inline/images/risunok5.png)

### Выводы - Git 101

- Git — система контроля и управления версиями
- Репозиторий (Repository) — место, где хранятся и поддерживаются какие-либо данные
- Коммит (Commit) — зафиксированное состояние репозитория
- Ветка (Branch) — указатель на коммит
- Запрос на слияние (Pull request или Merge request) – запрос на слияние двух состояний репозитория


## Методологии разработки (Git flows)

Методологии разработки на основе Git это серия подходов к разработке программного обеспечения использующих Git в качестве основы разработки. Существует множество методологий разработки, рассмотрим две из них:

- GitHub flow
- GitLab flow

### GitHub flow

GitHub flow является, наверное, одной из самых простых методологий разваботки на основе Git. ВОт она:

- Для каждой новой фичи создаём новую ветку, называемую веткой фичи (feature branch)
- Изменения коммитятся в ветку фичи
- После того как изменения закомичены отправляется запрос на слияние
- Запрос на слияние обсуждается и дорабатывается
- Запрос на слияние одобряется

Кроме того существует ряд правил:

- Ветка `master` всегда находится в работоспособном состоянии
- В ветке `master` не идёт разработка
- Разработка ведётся в ветках фич
- Ветка `master` == промышленное окружение*
- Промышленное окружение обновляется с каждым изменением ветки `master`


* Окружение это некое сконфигурированное место где исполняется код вашего приложения. Это может быть сервер, виртуальная  машина или даже контейнер.

Вот как это выглядит:

![GitHub](https://community.intersystems.com/sites/default/files/inline/images/risunok6.png)

Подробно про GitHub flow на Хабре уже [писали](https://habrahabr.ru/post/346066/) и не [раз](https://habrahabr.ru/post/189046/). 

### GitLab flow

Если вы не готовы автоматически обновлять код на промышленном окружении, GitLab flow предоставляет единение GitHub flow с несколькими окружениями. Вот как это работает: разработка ведётся аналогично GitHub flow - в отдельных ветках, которые также сливаются в `master`, но содержимое ветки `master` развёрнуто на тестовом сервере. Дополнительно у вас есть ветки окружений содержимое которых соответствует содержимому ваших окружений. Обычно существует три окружения но их может быть больше или меньше в зависимости от ваших ребований:

- Тестовое окружение == ветка `master`
- Опытное окружение  == ветка `preprod` 
- Промышленное окружение == ветка `prod`

Выглядит процесс разработки так:

![](https://community.intersystems.com/sites/default/files/inline/images/risunok7.png)

Подробно про GitLab flow на Хабре тоже [писали](https://habrahabr.ru/company/softmart/blog/316686/).

## Выводы - Методологии разработки (Git flows)

Существует ряд методологий разработки основанных на Git - от простых до сложных. Выберите ту методологию которая с одной стороны не переусложнена, с другой обеспечивает надлежащий уровнь контроля за состоянием вашего проекта.

## GitLab Workflow

GitLab Workflow - методология разработки програмного обеспечения, которая затрагивает не только этапы разработки но весь жизненный цикл продукта от идеи до отзывов ползователей. Вот как он выглядит:

GitLab Workflow is a logical sequence of possible actions to be taken during the entire lifecycle of the software development process.

GitLab Workflow takes into account the GitLab Flow, which we discussed in a previous article. Here's how it looks like:

- Идея: новая функциональность начинается с идеи.
- Задача (Issue): наиболее эффективным способом обсуждения идеи является создание для нее задача. Ваша команда помогут  и улучшить идею, предложить пути её реализации.
- План: как только обсуждение задачи придет к чему-либо, пришло время писать код. Но, во-первых, нам необходимо расставить приоритеты и организовать наш рабочий процесс, для этого есть этапы, канбан доска, дата исполнения и ответственный.
- Код: теперь мы готовы написать код.
- Комит: как только мы  довольны нашим кодом, можно перенести его в ветвь с контролем версий. GitLab flow был подробно описан выше.
- Тест: запустите скрипты с помощью GitLab CI, чтобы создать и протестировать приложение.
- Ревью: как только наш код работает, тесты и сборки проходят успешно, можно вручную проверить код на код-ревью.
- Опытная эксплуатация: теперь пришло время развернуть наш код в опытном окружении, чтобы проверить, все ли работает, как мы ожидали, или если нам все еще нужны корректировки.
- Промышленная эксплуатация: пришло время для развертывания в промышленном окружении
- Обратная связь: пришло время оглянуться назад и проверить, что нуждается в улучшении.

![](https://community.intersystems.com/sites/default/files/inline/images/idea-to-production-10-steps.png)

Подробно каждый этап описан на [сайте GitLab](https://about.gitlab.com/2016/10/25/gitlab-workflow-an-overview/), я ограничусь описанием нескольких этапов.

### Задачи и планирование

Начальные этапы GitLab workflow сосредоточены на задаче - новой функциональности, ошибке или каком-либо другом отдельном объёме работ. Задача имеет несколько целей, таких как:

- Управление: в задаче есть даты создания и исполнения, ответственный, временные затраты, приоритет и т. д., для отслеживания решения проблемы.
- Административный: проблема является частью этапа разработки, а также канбан доски, что позаоляет формировать план работ и следить за его выполнением.
- Разработка: в задаче можно обсуждать пути её решения, коммиты, ветки, запросы на слияние и другие задачи также могут быть связаны с задачей.

Этап планирования позволяет группировать задачи по их приоритету, этапу, статусу.

![](https://community.intersystems.com/sites/default/files/inline/images/issue-board.gif)

Разработка мы обсудили выше,  следуйте любой методологии разработки git. После того, как мы разработали нашу новую функциональность и слили её в ветку `master` - что будет дальше?

### Continuous Delivery (непрерывная доставка)

Непрерывная доставка - это подход к разработке программного обеспечения, в котором команды разрабатывают программное обеспечение в коротких спринтах, гарантируя, что новая версия приложения может быть выпущена в любое время. Данный подход автоматизирует сборку, тестирование и доставку программного обеспечения. Этот подход помогает снизить затраты и риски внесения изменений, позволяя получать быстрые инкрементные обновления для приложений в промышленной эксплуатации. Для непрерывной доставки важно настроить простой и воспроизводимый процесс доставки.

### Непрерывная доставка в GitLab

В GitLab конфигурации непрерывной доставки определяется отдельно для каждого репозитория определяется и хранится в файле конфигурации YAML в корне репозитория.

- Конфигурация непрерывной доставки - это серия последовательных этапов.
- Каждый этап имеет один или несколько скриптов, которые выполняются параллельно.

#### Скрипт

Определяет одно действие и какие условия должны выполняться для его запуска:

- Что делать (выполнить команду ОС, запустить контейнер)?
- Когда запускать скрипт:
    - Триггер (например коммит в ветку `master`)?
    - Запускать ли скрипт, если предыдущие этапы не удались (по-умолчанию нте)?
    - Запуск вручную или автоматически?
- В какой среде запускать скрипт?
- Какие артефакты сохраняются после выполнения (они загружаются из окружения в GitLab для быстрого доступа)?

**Окружение** - это настроенный сервер или контейнер, в котором вы можете запускать скрипты.

**Runners** - выполняют скрипты в определенных окружениях. Они подключены к GitLab и выполняют скрипты по мере необходимости.
Runner может быть развернут на сервере, в контейнере или даже на вашей локальной машине.

Как происходит непрерывная доставка?

- Новый коммит загружается в репозиторий.
- GitLab проверяет конфигурацию непрерывной доставки.
- Конфигурация непрерывной доставки содержит все возможные скрипты для всех случаев, поэтому они отфильтровываются до набора сценариев, которые должны выполняться для этого конкретного коммита (например, скрипт для ветки `master` срабатывает только в случае коммита в ветку `master`). Этот набор называется **запуском** (pipeline).
- Запуск выполняется в соответствующем окружении, результаты выполнения сохраняются и доступны на GitLab.

Вот пример запуска:

![](https://community.intersystems.com/sites/default/files/inline/images/risunok1_2.png)

Он состоит из четырех этапов, выполняемых последовательно

- Load загружает код на сервер
- Tets запускает юнит тесты
- Package состоит из двух скриптов, выполняемых параллельно:
  - Сборка клиента
  - Экспорт серверного кода в один "xml" (в основном для информационных целей)
- Deploy перемещает собранный клиент в каталог веб-сервера.

Как мы видим, каждый скрипт выполнился успешно, если бы один из скриптов завершился неудачно, следующие скрипты не будут выполняться:

![](https://community.intersystems.com/sites/default/files/inline/images/snimok_33.png)

Если открыть скрипт, можно увидеть почему он закончился ошибкой по логу:

```
Running with gitlab-runner 10.4.0 (857480b6)
 on test runner (ab34a8c5)
Using Shell executor...
Running on gitlab-test...
Fetching changes...
Removing diff.xml
Removing full.xml
Removing index.html
Removing tests.html
HEAD is now at a5bf3e8 Merge branch '4-versiya-1-0' into 'master'
From http://gitlab.eduard.win/test/testProject
 * [new branch] 5-versiya-1-1 -> origin/5-versiya-1-1
 a5bf3e8..442a4db master -> origin/master
 d28295a..42a10aa preprod -> origin/preprod
 3ac4b21..7edf7f4 prod -> origin/prod
Checking out 442a4db1 as master...
Skipping Git submodules setup
$ csession ensemble "##class(isc.git.GitLab).loadDiff()"

[2018-03-06 13:58:19.188] Importing dir /home/gitlab-runner/builds/ab34a8c5/0/test/testProject/

[2018-03-06 13:58:19.188] Loading diff between a5bf3e8596d842c5cc3da7819409ed81e62c31e3 and 442a4db170aa58f2129e5889a4bb79261aa0cad0

[2018-03-06 13:58:19.192] Variable modified
var=$lb("MyApp/Info.cls")

Load started on 03/06/2018 13:58:19
Loading file /home/gitlab-runner/builds/ab34a8c5/0/test/testProject/MyApp/Info.cls as udl
Load finished successfully.

[2018-03-06 13:58:19.241] Variable items
var="MyApp.Info.cls"
var("MyApp.Info.cls")=""

Compilation started on 03/06/2018 13:58:19 with qualifiers 'cuk /checkuptodate=expandedonly'
Compiling class MyApp.Info
Compiling routine MyApp.Info.1
ERROR: MyApp.Info.cls(version+2) #1003: Expected space : '}' : Offset:14 [zversion+1^MyApp.Info.1]
 TEXT: 	quit, "1.0" }
Detected 1 errors during compilation in 0.010s.

[2018-03-06 13:58:19.252] ERROR #5475: Error compiling routine: MyApp.Info.1. Errors: ERROR: MyApp.Info.cls(version+2) #1003: Expected space : '}' : Offset:14 [zversion+1^MyApp.Info.1]
 > ERROR #5030: An error occurred while compiling class 'MyApp.Info'
ERROR: Job failed: exit status 1
```

Ошибка компиляции стала причиной неудачного выполнения скрипта.

Перейдём от теории к практике.

## Установка GitLab

Будем устанавливать GitLab на нашем собственном сервере. Впрочем можно пользоваться и просто GitLab.com. Существует много способов установки GitLab: из исходников, из пакета, в контейнете. Выберитте тот способ который вам нравится и следуйте [инструкции по установке](https://about.gitlab.com/installation/).

Требования:

- Отдельный сервер - GitLab достаточно ресурсоёмкое веб-приложение, поэтому лучше держать его на отдельном сервере (4 Gb RAM, 2 CPU)
- ОС Linux
- (Опционально но рекомендуется) Домен - необходим для обеспечения безопасности и запуска pages.

### Конфигурация

Прежде всего настройте [почтовые уведомления](https://docs.gitlab.com/omnibus/settings/smtp.html).

Далее, рекомендую установить Pages. Как было сказано выше, артефакты от скриптов могут быть загружены на GitLab. Пользователи могут  загрузить их, но часто бывает полезно открыть их напрямую в браузере и для этого нужно установить pages. 

Зачем нужны pages:

- Для хостинга вики или набора статичных страниц связанных с проектом.
- Для просмотра html артефактов.
- [И ряд других причин](https://docs.gitlab.com/ce/user/project/pages/#explore-gitlab-pages).

Так как в HTML может быть добавлено автоматическое перенаправление при загрузке страницы можно направлять пользователя на страницу с результатами юнин-тестов.

```
ClassMethod writeTestHTML()
{
  set text = ##class(%Dictionary.XDataDefinition).IDKEYOpen($classname(), "html").Data.Read()
  set text = $replace(text, "!!!", ..getURL())
  
  set file = ##class(%Stream.FileCharacter).%New()
  set name = "tests.html"
  do file.LinkToFile(name)
  do file.Write(text)
  quit file.%Save()
}

ClassMethod getURL()
{
  set url = "http://host:57772"
  set url = url _ $system.CSP.GetDefaultApp("%SYS")
  set url = url_"/%25UnitTest.Portal.Indices.cls?Index="_ $g(^UnitTest.Result, 1) _ "&$NAMESPACE=" _ $zconvert($namespace,"O","URL")
  quit url
}

XData html
{
<html lang="en-US">
  <head>
    <meta charset="UTF-8"/>
    <meta http-equiv="refresh" content="0; url=!!!"/>
    <script type="text/javascript">window.location.href = "!!!"</script>
  </head>
  <body>
    If you are not redirected automatically, follow this <a href='!!!'>link to tests</a>.
  </body>
</html>
}
```

Кстати я столкнулся с багом при использовании pages (Ошибка 502 при просмотре артефактов) - вот [решение](https://gitlab.com/gitlab-com/infrastructure/issues/3064).

### Подключение окружений к GitLab

Для запуска CD скриптов необходимы окружения - настроенные серверы для запуска вашего приложения. Для начала предположим, что у вас установлен Linux-сервер с платформой InterSystems (скажем, InterSystems IRIS, но всё будет работать с Caché или Ensemble). Для соединения окружения с GitLab нужно:

1. [Установить GitLab runner](https://docs.gitlab.com/runner/).
2. [Зарегистрировать](https://docs.gitlab.com/runner/register/index.html) GitLab runner в GitLab.
3. Разрешить юзеру `gitlab-runner` вызывать InterSystems IRIS.

Важное замечание по установке GitLab runner - НЕ клонируйте сервер после установки GitLab runner. Результаты непредсказуемы и нежелательны.
Поподробнее о шагах 2, 3.

#### Зарегистрировать GitLab runner в GitLab.

После запуска команды: `sudo gitlab-runner register`

Будет предложено несколько опций на выбор, и хотя большинство шагов довольно просто, некоторые из них стоит прокомментировать:

**Please enter the gitlab-ci token for this runner**

Доступно несколько токенов:

- Для всей системы (доступен в настройках администрирования)
- Для одного проекта (доступен в настройках проекта)

Когда вы подключаете runner для CD конкретного проекта, нужно указать токен именно этого проекта.

**Please enter the gitlab-ci tags for this runner (comma separated)**

В  CD конфигурации можно фильтровать, какие скрипты выполняются окружениях с определёнными тегами. Поэтому в самом простом случае укажите один тег, который будет названием окружения.

**Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:**

Вне зависимости от того используете ли вы docker, выбирайте shell для запуска скриптов.
